// Return [rhi, rlo] = b ? [hi0, lo0] : [hi1, lo1].
inline
fn bn_sel512(reg u256 hi0 lo0 hi1 lo1, reg bool b) -> reg u256, reg u256 {
    reg u256 rlo rhi;
    rlo = b ? lo0 : lo1;
    rhi = b ? hi0 : hi1;
    return rhi, rlo;
}

// Return cf, [rhi, rlo] = [ahi, alo] + [bhi, blo].
inline
fn bn_add512(reg u256 ahi alo bhi blo) -> reg bool, reg u256, reg u256 {
    reg u256 rhi rlo;
    reg bool cf;
    cf, rlo = alo +256u blo;
    cf, rhi = ahi +256u bhi + cf;
    return cf, rhi, rlo;
}

// Return bf, [rhi, rlo] = [ahi, alo] - [bhi, blo].
inline
fn bn_sub512(reg u256 ahi alo bhi blo) -> reg bool, reg u256, reg u256 {
    reg u256 rhi rlo;
    reg bool bf;
    bf, rlo = alo -256u blo;
    bf, rhi = ahi -256u bhi - bf;
    return bf, rhi, rlo;
}

// Return [rhi, rlo] = [a, b] >> sham.
inline
fn bn_rshi512(reg u256 a b z, inline int sham) -> reg u256, reg u256 {
    reg u256 rhi rlo;
    rhi = #BN_RSHI(z, a, sham);
    rlo = #BN_RSHI(a, b, sham);
    return rhi, rlo;
}

/* Unrolled 768=384x384 bit multiplication.

   Returns c = a x b.

   Flags: Last instruction performs a dummy addition on the highest limb of c.
   Therefore the routine is left with the flags being set based on this
   operation:
      - M: MSb of the result (and the highest limb of the result)
      - L: LSb of the highest limb of result
      - Z: Indicates if highest limb of result is zero
      - C: Never set

   Clobbered registers: ACC. */
fn mul384(
    reg u256 ahi alo,     // a, first operand, max. length 384 bit.
    reg u256 bhi blo,     // b, second operand, max. length 384 bit.
    reg u256 z,           // All-zero.
    reg u256 c2 c1 c0,    // Output registers.
    reg bool mf0 lf0 zf0) // FG0.
    ->
    reg u256, reg u256, reg u256, // c, result, max. length 768 bit.
    reg bool, reg bool, reg bool // FG0.M, FG0.L, FG0.Z flags
{
    reg u256 acc;

    acc = #BN_MULQACC_Z(alo, 0, blo, 0, 0);
    acc = #BN_MULQACC(alo, 0, blo, 1, acc, 64);
    ?{mf0, lf0, zf0, acc}, c0
         = #BN_MULQACC_SO_L(mf0, lf0, zf0, c0, alo, 1, blo, 0, acc, 64);
    acc = #BN_MULQACC(alo, 0, blo, 2, acc,  0);
    acc = #BN_MULQACC(alo, 1, blo, 1, acc,  0);
    acc = #BN_MULQACC(alo, 2, blo, 0, acc,  0);
    acc = #BN_MULQACC(alo, 0, blo, 3, acc, 64);
    acc = #BN_MULQACC(alo, 1, blo, 2, acc, 64);
    acc = #BN_MULQACC(alo, 2, blo, 1, acc, 64);
    ?{mf0, lf0, zf0, acc}, c0
         = #BN_MULQACC_SO_U(mf0, lf0, zf0, c0, alo, 3, blo, 0, acc, 64);

    acc = #BN_MULQACC(alo, 0, bhi, 0, acc,  0);
    acc = #BN_MULQACC(alo, 1, blo, 3, acc,  0);
    acc = #BN_MULQACC(alo, 2, blo, 2, acc,  0);
    acc = #BN_MULQACC(alo, 3, blo, 1, acc,  0);
    acc = #BN_MULQACC(ahi, 0, blo, 0, acc,  0);
    acc = #BN_MULQACC(alo, 0, bhi, 1, acc, 64);
    acc = #BN_MULQACC(alo, 1, bhi, 0, acc, 64);
    acc = #BN_MULQACC(alo, 2, blo, 3, acc, 64);
    acc = #BN_MULQACC(alo, 3, blo, 2, acc, 64);
    acc = #BN_MULQACC(ahi, 0, blo, 1, acc, 64);
    ?{mf0, lf0, zf0, acc}, c1
         = #BN_MULQACC_SO_L(mf0, lf0, zf0, c1, ahi, 1, blo, 0, acc, 64);
    acc = #BN_MULQACC(alo, 1, bhi, 1, acc,  0);
    acc = #BN_MULQACC(alo, 2, bhi, 0, acc,  0);
    acc = #BN_MULQACC(alo, 3, blo, 3, acc,  0);
    acc = #BN_MULQACC(ahi, 0, blo, 2, acc,  0);
    acc = #BN_MULQACC(ahi, 1, blo, 1, acc,  0);
    acc = #BN_MULQACC(alo, 2, bhi, 1, acc, 64);
    acc = #BN_MULQACC(alo, 3, bhi, 0, acc, 64);
    acc = #BN_MULQACC(ahi, 0, blo, 3, acc, 64);
    ?{mf0, lf0, zf0, acc}, c1
         = #BN_MULQACC_SO_U(mf0, lf0, zf0, c1, ahi, 1, blo, 2, acc, 64);

    acc = #BN_MULQACC(alo, 3, bhi, 1, acc,  0);
    acc = #BN_MULQACC(ahi, 0, bhi, 0, acc,  0);
    acc = #BN_MULQACC(ahi, 1, blo, 3, acc,  0);
    acc = #BN_MULQACC(ahi, 0, bhi, 1, acc, 64);
    ?{mf0, lf0, zf0, acc}, c2
         = #BN_MULQACC_SO_L(mf0, lf0, zf0, c2, ahi, 1, bhi, 0, acc, 64);
    ?{acc}, c2 = #BN_MULQACC_SO_U(mf0, lf0, zf0, c2, ahi, 1, bhi, 1, acc, 0);

    ?{mf0, lf0, zf0}, c2 = #BN_ADD(c2, z);

    return c2, c1, c0, mf0, lf0, zf0;
}

/* 384-bit modular multiplication based on Barrett reduction algorithm.
   Returns c = a x b % m.
   Clobbered flag groups: FG0 */
fn barrett384(
    reg u256 ahi alo,     // a, first operand, max. length 384 bit, a < m.
    reg u256 bhi blo,     // b, second operand, max. length 384 bit, b < m.
    reg u256 mhi mlo,     // m, modulus, max. length 384 bit, 2^384 > m > 2^383.
    reg u256 uhi ulo,     // u, pre-computed Barrett constant (without u[384]/MSb.
    reg u256 z,           // All-zero.
    reg u256 x_2 x_1 x_0, // Output registers.
    reg bool mf0 lf0 zf0) // Flags.
    -> reg u256, reg u256 // c, result, max. length 384 bit.
{
    // x = [x_2, x_1, x_0]
    x_2, x_1, x_0, mf0, lf0, zf0 = mul384(
        ahi, alo,
        bhi, blo,
        z,
        x_2, x_1, x_0,
        mf0, lf0, zf0
    );

    // u0 = M ? u : 0
    //    = M ? [uhi, ulo] : 0
    reg u256 u0hi u0lo;
    u0hi, u0lo = bn_sel512(uhi, ulo, z, z, mf0);

    // Save the two lower limbs of x.
    reg u256 s_x_0 s_x_1;
    s_x_0 = x_0;
    s_x_1 = x_1;

    // q1 = x >> 383
    //    = [x_2, x_1, x_0] >> 383
    //    = [x_2, x_0] >> 127
    reg u256 q1hi q1lo;
    q1hi, q1lo = bn_rshi512(x_2, x_1, z, 127);

    // q2' = q1[383:0] * u[383:0]
    //     = [q1hi, q1lo] * [uhi, ulo]
    reg u256 q2phi q2plo __q2dummy;
    ulo = ulo;
    uhi = uhi;
    q2phi, q2plo, __q2dummy, _, _, _ = mul384(
        q1hi, q1lo,
        uhi, ulo,
        z,
        x_2, x_1, x_0,
        mf0, lf0, zf0
    );

    // q2'' = q2' >> 384
    reg u256 q2pphi q2pplo;
    q2pphi, q2pplo = bn_rshi512(q2phi, q2plo, z, 128);

    // q2''' = q2'' + q1
    reg bool cf;
    reg u256 q2ppphi q2ppplo;
    _, q2ppphi, q2ppplo = bn_add512(q2pphi, q2pplo, q1hi, q1lo);

    // q2'''' = x[767] ? (q2''' + u[383:0]) : q2'''
    reg u256 q2pppphi q2pppplo;
    cf, q2pppplo = q2ppplo +256u u0lo;
    ?{mf0, lf0, zf0}, q2pppphi = #BN_ADDC(q2ppphi, u0hi, cf);

    // q3 = q2 >> 385
    //    = q2'''' >> 1
    reg u256 q3hi q3lo;
    q3hi, q3lo = bn_rshi512(q2pppphi, q2pppplo, z, 1);

    // r2 = q3 * m
    reg u256 r2_2 r2_1 r2_0;
    mlo = mlo;
    mhi = mhi;
    r2_2, r2_1, r2_0, _, _, _ = mul384(
        q3hi, q3lo,
        mhi, mlo,
        z,
        q2phi, q2plo, __q2dummy,
        mf0, lf0, zf0
    );

    // r = x - q3 * m
    //   = x - r2
    reg bool bf;
    reg u256 rhi rlo;
    _, rhi, rlo = bn_sub512(s_x_1, s_x_0, r2_1, r2_0);

    // c = a * b % m
    //   = ??
    reg u256 chi clo;
    bf, chi, clo = bn_sub512(rhi, rlo, mhi, mlo);
    rhi, rlo = bn_sel512(rhi, rlo, chi, clo, bf);

    bf, chi, clo = bn_sub512(rhi, rlo, mhi, mlo);
    chi, clo = bn_sel512(rhi, rlo, chi, clo, bf);

    return chi, clo;
}

inline
fn _main(reg u256 ahi alo bhi blo mhi mlo uhi ulo) -> reg u256, reg u256 {
    reg u256 c2 c1 c0 z;
    reg bool mf0 lf0 zf0;
    ?{}, c2 = #set0_256();
    ?{}, c1 = #set0_256();
    ?{}, c0 = #set0_256();
    ?{mf0, lf0, zf0}, z = #set0_256();

    reg u256 clo chi;
    chi, clo = barrett384(
        ahi, alo,
        bhi, blo,
        mhi, mlo,
        uhi, ulo,
        c2, c1, c0,
        z,
        mf0, lf0, zf0
    );

    chi = chi;
    clo = clo;

    return chi, clo;
}

/* Externally callable wrapper for modular multiplication with Barrett
   reduction.
   Returns c = a x b % m.
   Clobbered flag groups: FG0 */
// Here we should load the arguments from DMEM, and write the results back.
export
fn main(reg u256 ahi alo bhi blo mhi mlo uhi ulo) -> reg u256, reg u256 {
    reg u256 chi clo;
    chi, clo = _main(ahi, alo, bhi, blo, mhi, mlo, uhi, ulo);
    return chi, clo;
}


// -----------------------------------------------------------------------------
// Mock

// These bytes, in the .data section, will be overwritten by the main core:
// that's how it passes arguments to OTBN.
u64[4 * 8] data =
    {
        0x1, 0x0, 0x0, 0x0, // alo
        0x0, 0x0, 0x0, 0x0, // ahi
        0x1, 0x0, 0x0, 0x0, // blo
        0x0, 0x0, 0x0, 0x0, // bhi
        0x0, 0x0, 0x0, 0x0, // mlo
        0x0, 0x0, 0x0, 0x0, // mhi
        0x0, 0x0, 0x0, 0x0, // ulo
        0x0, 0x0, 0x0, 0x0  // uhi
    };

// This is generic.
param int NDATA = 8;
require "load_data.jazz"

export
fn mock() -> reg u256, reg u256 {
    reg u256[8] rdata;
    rdata = load_data();

    reg u256 chi clo;
    chi, clo = _main(
        rdata[1],
        rdata[0],
        rdata[3],
        rdata[2],
        rdata[5],
        rdata[4],
        rdata[7],
        rdata[6]
    );

    return chi, clo;
}

exec mock()
