/* -------------------------------------------------------------------------- */
/* Module parameters. */

param int N = 3;
param int M = 3;


/* -------------------------------------------------------------------------- */
/* Library. */

inline
fn min(inline int x y) -> inline int {
    inline int r;
    r = x <= y ? x : y;
    return r;
}

inline
fn max(inline int x y) -> inline int {
    inline int r;
    r = x > y ? x : y;
    return r;
}


/* -------------------------------------------------------------------------- */

param int T = N + M;

inline
fn loop_body(
    reg u256[N] a,
    reg u256[M] b,
    reg u256[T] out,
    reg u256 z acc,
    reg bool mf0 lf0 zf0,
    inline int i j k)
    -> reg u256, reg bool, reg bool, reg bool, reg u256[T]
{
    inline int sham;
    sham = k * 64;

    // In the last word, since we don't do half-word writeback
    // we need to shift 0, 64, 128, and 192.
    // So if we're on the second 128-bit part we have an offset of
    // 128.
    if (i == T - 1 && j == 1) {
        sham += 128;
    }

    // Current 64-bit part.
    inline int t;
    t = 4 * i + 2 * j + k;

    // [k] and [t - k] are the indexes for multiplicating 64-bit
    // chunks of the arguments.
    // idx indexes a so 0 <= idx < N
    // t - idx indexes b so 0 <= t - idx < M
    inline int idx_min idx_max;
    idx_min = max(0, t - M + 1);
    idx_max = min(N - 1, t);

    inline int idx a_w b_w a_q b_q;
    for idx = idx_min to idx_max {
        a_w = idx / 4;
        b_w = (t - idx) / 4;
        a_q = idx % 4;
        b_q = (t - idx) % 4;

        if (t == 0 && idx == idx_min) {
            acc = #BN_MULQACC_Z(a[a_w], a_q, b[b_w], b_q, sham);
        } else {
            acc = #BN_MULQACC(a[a_w], a_q, b[b_w], b_q, acc, sham);
        }
    }

    idx = idx_max;
    a_w = idx / 4;
    b_w = (t - idx) / 4;
    a_q = idx % 4;
    b_q = (t - idx) % 4;

    // In the last iteration, we have two special cases to consider.
    // When the last partial product spills into the last word
    // (i.e. no partial product starts on the last word),
    // we need to get the leftover bits from the accumulator
    // using mulqacc.wo ..., w31, w31, 0
    // For instance when N = 1 and M = 4.
    // Else, we need to skip half-word writebacks and do a whole
    // word writeback at the very end.
    // For instance,
    // mulqacc         w8.0, w10.0, 0
    // mulqacc.wo w14, w8.0, w10.1, 64
    // otherwise we lose the upper 128 bits.
    if (i == T - 1) {
        if (idx_max < idx_min) {
            if (j == 1 && k == 1) {
                ?{acc}, out[i] = #BN_MULQACC_WO(z, 0, z, 0, acc, 0);
            }
        } else {
            if (j == 1 && k == 1) {
                // Whole word writeback.
                ?{acc}, out[i] = #BN_MULQACC_WO(a[a_w], a_q, b[b_w], b_q, acc, sham);
            } else {
                // No writeback.
                acc = #BN_MULQACC(a[a_w], a_q, b[b_w], b_q, acc, sham);
            }
        }
    } else if (k == 1) {
        // Half-word writeback.
        if (j == 0) {
            ?{mf0, lf0, zf0, acc}, out[i / 2] = #BN_MULQACC_SO_L(
                mf0, lf0, zf0,
                out[i / 2],
                a[a_w], a_q,
                b[b_w], b_q,
                acc,
                sham
            );
        } else {
            ?{mf0, lf0, zf0, acc}, out[i / 2] = #BN_MULQACC_SO_U(
                mf0, lf0, zf0,
                out[i / 2],
                a[a_w], a_q,
                b[b_w], b_q,
                acc,
                sham
            );
        }
    } else {
        // No writeback.
        acc = #BN_MULQACC(a[a_w], a_q, b[b_w], b_q, acc, sham);
    }

    return acc, mf0, lf0, zf0, out;
}

inline
fn widemul(reg u256[N] a, reg u256[M] b, reg u256[T] out) -> reg u256[T] {
    reg u256 acc z;
    reg bool mf0, lf0, zf0;

    ?{mf0, lf0, zf0}, z = #set0();

    inline int i;
    for i = 0 to T {

        inline int j;
        for j = 0 to 2 { // Iterate over 128-bit parts.

            inline int k;
            for k = 0 to 2 { // Iterate over 64-bit parts.

                acc, mf0, lf0, zf0, out = loop_body(
                    a, b,
                    out,
                    z,
                    acc,
                    mf0, lf0, zf0,
                    i, j, k
                );

            }
        }
    }

    return out;
}

export
fn mock() -> reg u256, reg u256 {

    reg u256[N] a;
    reg u256[M] b;
    reg u256[T] out;

    ?{}, a[0] = #set0();
    ?{}, a[1] = #set0();
    ?{}, a[2] = #set0();

    ?{}, b[0] = #set0();
    ?{}, b[1] = #set0();
    ?{}, b[2] = #set0();

    ?{}, out[0] = #set0();
    ?{}, out[1] = #set0();
    ?{}, out[2] = #set0();
    ?{}, out[3] = #set0();
    ?{}, out[4] = #set0();
    ?{}, out[5] = #set0();

    out = widemul(a, b, out);

    reg u256 x y;

    x = out[0];
    y = out[1];

    return x, y;
}

//exec mock()
