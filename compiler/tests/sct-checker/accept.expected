File annot.jazz:
modmsf f : #transient x ->
#secret
output corruption: #public
constraints:


modmsf id : #poly = { n = k, s = k} arg ->
#poly = { n = k, s = k}
output corruption: #public
constraints:
k <= k, 

nomodmsf id1 : #poly = { n = k, s = k} arg ->
#poly = { n = k, s = k}
output corruption: #public
constraints:


nomodmsf id2 : #[ptr = { n = p, s = p}, val = { n = v, s = v}] arg ->
#[ptr = { n = p, s = p}, val = { n = v, s = v}]
output corruption: #public
constraints:


nomodmsf id3 : #public arg ->
#public
output corruption: #public
constraints:


nomodmsf id4 : #transient arg ->
#transient
output corruption: #public
constraints:


nomodmsf id5 : #secret arg ->
#secret
output corruption: #public
constraints:


File arrays.jazz:
modmsf transient_read : #[ptr = transient, val = { n = d, s = secret}] p *
                        #transient i ->
#poly = { n = d, s = secret}
output corruption: #public
constraints:


modmsf safe_access : #public c * #poly = { n = d, s = d} x ->
#poly = { n = d, s = d}
output corruption: #public
constraints:


File basic.jazz:
modmsf nothing : #transient a ->
#public
output corruption: #public
constraints:


nomodmsf secret : #secret a ->
#secret
output corruption: #public
constraints:


modmsf branch : #transient a * #secret b * #secret c ->
#secret
output corruption: #public
constraints:


nomodmsf branchless : #transient a * #secret b * #secret c ->
#secret
output corruption: #public
constraints:


modmsf forloop : #transient a ->
#public
output corruption: #public
constraints:


modmsf whileloop : #transient a ->
#public
output corruption: #public
constraints:


modmsf archetype : #transient i ->
#transient
output corruption: #public
constraints:


modmsf load : #transient p * #transient i ->
#public
output corruption: #public
constraints:


modmsf store : #transient p * #transient i * #transient q * #secret v ->

output corruption: #transient
constraints:


modmsf msf_after_for_loop : #transient x ->
#public
output corruption: #public
constraints:


modmsf msf_init_in_for_loop : #transient x ->
#public
output corruption: #public
constraints:


modmsf msf_mov_in_for_loop : #transient x ->
#public
output corruption: #public
constraints:


modmsf for_loop_one_iter : #transient x ->
#public
output corruption: #public
constraints:


nomodmsf zero_iterations_dont_mod_msf_aux : #public x ->

output corruption: #public
constraints:


modmsf zero_iterations_dont_mod_msf : #transient x ->
#public
output corruption: #public
constraints:


File local-stack-array.jazz:
modmsf main : #transient io ->
#public
output corruption: #public
constraints:


File paper.jazz:
modmsf fig3a : #[ptr = transient, val = transient] p *
               #[ptr = transient, val = secret] w * #transient i ->
#[ptr = public, val = secret]
output corruption: #public
constraints:


modmsf fig3b : #[ptr = transient, val = transient] p *
               #[ptr = transient, val = { n = w, s = w}] w *
               #[ptr = transient, val = { n = s, s = s}] s * #transient i *
               #secret secret ->
#[ptr = public, val = { n = w, s = w}] *
#[ptr = public, val = { n = s, s = s}]
output corruption: #transient
constraints:
w <= w, s <= s, 

modmsf fig4a : #[ptr = public, val = { n = d, s = d}] msg *
               #[ptr = public, val = secret] key ->
#[ptr = public, val = { n = d, s = d}]
output corruption: #transient
constraints:


modmsf fig4b : #[ptr = transient, val = { n = d, s = d}] msg *
               #[ptr = transient, val = secret] key ->
#[ptr = public, val = { n = d, s = d}]
output corruption: #transient
constraints:
d <= d, 

modmsf fig4c : #[ptr = transient, val = { n = d, s = d}] msg *
               #[ptr = transient, val = secret] key ->
#[ptr = public, val = { n = d, s = d}]
output corruption: #transient
constraints:
d <= d, 

modmsf fig5a : #[ptr = public, val = { n = d, s = secret}] p ->
#poly = { n = d, s = secret}
output corruption: #public
constraints:


modmsf fig5b : #[ptr = transient, val = { n = d, s = d}] p ->
#poly = { n = d, s = d}
output corruption: #public
constraints:
d <= d, 

modmsf fig5c : #[ptr = transient, val = { n = d, s = d}] p ->
#poly = { n = d, s = d}
output corruption: #public
constraints:
d <= d, 

modmsf fig6a : #[ptr = transient, val = secret] s *
               #[ptr = transient, val = transient] p * #transient i *
               #transient pub_v ->
#public * #[ptr = public, val = secret]
output corruption: #public
constraints:


modmsf fig6b : #[ptr = transient, val = secret] s *
               #[ptr = transient, val = transient] p * #transient cond *
               #secret sec_v ->
#public * #[ptr = public, val = secret]
output corruption: #public
constraints:


File while.jazz:
modmsf while_first_branch : #public pub * #secret sec ->
#public
output corruption: #public
constraints:


