#[test=nosct]
inline
fn leak(reg u64 x) {
    if (x == 0) { [x] = 0; }
}

#[test=nosct]
fn do_nothing() {}

#[test=nosct]
fn id(reg u64 x) -> reg u64 {
    return x;
}

#[test=nosct]
fn id_msf(reg u64 x) -> #msf reg u64 {
    return x;
}

fn archetypical(#public reg u64 pub, #secret reg u64 sec) {
    reg u64 x;
    x = id(pub);
    leak(x);
    _ = id(sec);
}

fn transient_after_call_update(#transient reg u64 x) -> #public reg u64 {
    reg u64 msf;
    msf = #init_msf();
    #update_after_call
    _ = id_msf(msf);
    return x;
}

fn transient_after_call_noupdate(#transient reg u64 x) -> #public reg u64 {
    _ = #init_msf();
    do_nothing();
    return x;
}

fn transient_after_call_noupdate1(#transient reg u64 x) -> #public reg u64 {
    reg u64 msf;
    msf = #init_msf();
    do_nothing();
    return x;
}

fn transient_after_call_noupdate2(#transient reg u64 x) -> #public reg u64 {
    reg u64 msf;
    msf = #init_msf();
    msf = id_msf(msf);
    return x;
}

fn call_in_while(#transient reg u64 x) -> #public reg u64 {
    reg u64 msf;
    msf = #init_msf();

    while (x < 5) {
        msf = #update_msf(x < 5, msf);
        #update_after_call
        msf = id_msf(msf);
    }

    return x;
}

fn call_in_while_unknown(#transient reg u64 x) -> #public reg u64 {
    reg u64 msf;
    msf = #init_msf();

    while (x < 5) {
        do_nothing();
    }

    return x;
}

fn call_in_while_noupdate(#transient reg u64 x) -> #public reg u64 {
    reg u64 msf;
    msf = #init_msf();

    while (x < 5) {
        msf = #update_msf(x < 5, msf);
        do_nothing();
    }

    return x;
}

fn call_in_for(#transient reg u64 x) -> #public reg u64 {
    reg u64 msf;
    msf = #init_msf();

    inline int i;
    i = 1;
    for i = 0 to i {
        #update_after_call
        msf = id_msf(msf);
    }

    return x;
}

fn call_in_for_noupdate(#transient reg u64 x) -> #public reg u64 {
    reg u64 msf;
    msf = #init_msf();

    inline int i;
    i = 1;
    for i = 0 to i {
        do_nothing();
    }

    return x;
}

fn write_mmx_assign(#transient reg u64 x) -> #transient #mmx reg u64 {
    #mmx reg u64 m;
    m = x;
    return m;
}

fn write_mmx_assign2(#secret reg u64 x) -> #secret #mmx reg u64 {
    #mmx reg u64 m;
    m = x;
    return m;
}

fn write_mmx_opn(#transient reg u64 x) -> #transient #mmx reg u64 {
    #mmx reg u64 m;
    m = #MOV(x);
    return m;
}

inline
fn write_mmx_ptr(#transient stack u64[1] a) -> reg u64 {
    #mmx reg ptr u64[1] m;
    m = a;
    a = m;

    reg u64 r;
    r = a[0];
    return r;
}

#test=nosct
fn move_to_mmx(#transient reg u64 x) -> #transient #mmx reg u64 {
    #mmx reg u64 m;
    m = x;
    return m;
}

fn write_mmx_call(#transient reg u64 x, #msf reg u64 msf) -> #transient reg u64 {
    #mmx reg u64 m;
    #update_after_call=msf
    m = move_to_mmx(x);
    x = m;
    return x;
}

fn write_mmx_call_noupdate(#transient reg u64 x) -> #transient reg u64 {
    #mmx reg u64 m;
    m = move_to_mmx(x);
    x = m;
    return x;
}

fn invalid_update_after_call() -> {
    reg u64 msf;
    msf = #init_msf();
    #update_after_call
    do_nothing();
}

#[test=nosct]
fn two_msf() -> #msf reg u64, #msf reg u64 {
    reg u64 msf0 msf1;
    msf0 = #init_msf();
    msf1 = #mov_msf(msf0);
    return msf0, msf1;
}

fn update_after_call_many() -> {
    reg u64 msf0 msf1;
    #update_after_call
    msf0, msf1 = two_msf();
}
